# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from libcpp cimport bool
from libcpp.string cimport string
from libcpp.vector cimport vector

import threading
from collections import defaultdict
from itertools import chain
from typing import Dict, Iterable, List, Optional, Text, Union

import mds
from mds import MDSTypeInfo, MDSArrayTypeInfo
from mds.threading import MDSThreadData

from mds.core.arrays cimport *
from mds.core.namespaces cimport *
from mds.core.primitives cimport *
from mds.core.records cimport *
from mds.core.strings cimport *
from mds.core.tasks cimport initialize_base_task

initialize_base_task()

# =========================================================================
#  Base
# =========================================================================

cdef class MDSObject(object):

    @classmethod
    def from_namespace(cls, namespace: Namespace, path: PathTypes):
        return NotImplemented

    def bind_to_namespace(self, namespace: Namespace, path: PathTypes) -> None:
        pass


cdef class MDSProxyObject(object):

    def __init__(self, proxied: MDSObject):
        self._proxied = proxied

    def __getattr__(self, item):
        return getattr(self._proxied, item)

    def __setattr__(self, key, value):
        if key.endswith("_proxied"):
            super().__setattr__(key, value)
        elif not hasattr(self._proxied, key):
            raise AttributeError("'{}' has no attribute '{}'".format(type(self._proxied).__name__, key))
        else:
            setattr(self._proxied, key, value)

# =========================================================================
#  Errors & Exceptions
# =========================================================================

cdef class UnderflowError(Exception):
    pass

# =========================================================================
#  Managed Values
# =========================================================================

cdef class MDSPrimitiveBase(MDSObject):

    def __int__(self):
        return int(self._to_python())

    def __float__(self):
        return float(self._to_python())

    def __sanitize_operand(self, other):
        if isinstance(other, MDSPrimitiveBase):
            other = other.python_value
        elif not isinstance(other, (int, float)):
            return NotImplemented

        return other

    def __add__(self, other):
        pyval = self.__sanitize_operand(other)
        return self.python_value + pyval

    def __sub__(self, other):
        pyval = self.__sanitize_operand(other)
        return self.python_value - pyval

    def __mul__(self, other):
        pyval = self.__sanitize_operand(other)
        return self.python_value * pyval

    def __truediv__(self, other):
        pyval = self.__sanitize_operand(other)
        return self.python_value / pyval

    def __floordiv__(self, other):
        pyval = self.__sanitize_operand(other)
        return self.python_value // pyval

    def __iadd__(self, other):
        other = self.__sanitize_operand(other)
        self.update(self.python_value + other)

    def __isub__(self, other):
        other = self.__sanitize_operand(other)
        self.update(self.python_value - other)

    def __imul__(self, other):
        other = self.__sanitize_operand(other)
        self.update(self.python_value * other)

    def __itruediv__(self, other):
        other = self.__sanitize_operand(other)
        self.update(self.python_value / other)

    def __ifloordiv__(self, other):
        other = self.__sanitize_operand(other)
        self.update(self.python_value // other)

    def _to_python(self):
        return NotImplemented

    def _sanitize(self, value, existing):
        if type(value) != type(existing):
            raise TypeError("Need the same types, got `{}` and `{}`.".format(
                    type(value), type(existing)
                )
            )

        return value

    def update_value(self, value) -> None:
        return NotImplemented

    property python_type:
        def __get__(self):
            return int

    property python_value:
        def __get__(self):
            return self._to_python()

    property dtype:
        def __get__(self):
            return None


cdef class MDSIntPrimitiveBase(MDSPrimitiveBase):

    def _sanitize(self, value, existing) -> int:
        if isinstance(value, float):
            value = int(value)
        elif not isinstance(value, int):
            t = type(value)
            raise TypeError(f'Unable to parse value of type `{t}`')

        if value < self.MIN:
            raise UnderflowError(f"Can't fit {value} in container {self.dtype}")
        elif value > self.MAX:
            raise OverflowError(f"Can't fit {value} in container {self.dtype}")

        return value

    property python_type:
        def __get__(self):
            return int

    property MIN:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")

    property MAX:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")


cdef class MDSFloatPrimitiveBase(MDSPrimitiveBase):

    property python_type:
        def __get__(self):
            return float

# =========================================================================
#  Arrays
# =========================================================================

cdef class MDSIndexedObject(MDSObject):
    cdef:
        int __iter_idx

    def __getitem__(self, item):
        return NotImplemented

    def __setitem__(self, item, value):
        pass

    def __iter__(self):
        self.__iter_idx = 0
        return self

    def __next__(self):
        if self.__iter_idx < len(self):
            retval = self[self.__iter_idx]
            self.__iter_idx += 1
            return retval
        else:
            raise StopIteration

    def __len__(self):
        return NotImplemented

    def _index_bounds_check(self, index: int) -> int:
         # TODO: Need to handle slices. Should this be a new array?
        cdef long l = <long> len(self)

        if index >= l or index < -l:
            raise IndexError('list index out of range')

        if index < 0:
            index += l

        return index

    def index(self, start=None, end=None) -> int:
        return NotImplemented # TODO Implement this

    def count(self, value) -> int:
        # TODO: Handle len 0, should this even be instantiable?
        # TODO: Bool still a str-literal here
        if not isinstance(value, type(self[0])):
            raise TypeError("value to be searched for must match list-type `bool`")

        cdef:
            size_t i = 0, l = len(self), c = 0

        for i in range(l):
            if self[i] == value:
                c += 1

        return c


cdef class MDSArrayBase(MDSIndexedObject):

    cdef size_t _last_index

    def __getitem__(self, index):
        index = self._index_bounds_check(index)

        # We store this for in-place ops
        self._last_index = index
        return self._to_python(index)

    def _to_python(self, index):
        raise NotImplementedError('Specialization of MDSList required')

    def _to_mds(self, index, value):
        raise NotImplementedError('Specialization of MDSList required')

    def copy(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')

    @classmethod
    def of(cls, values: Iterable):
        retval = cls(length=len(values))

        for i, elem in enumerate(values):
            retval[i] = elem

        return retval

    property dtype:
        def __get__(self):
            raise NotImplementedError('Specialization of MDSArrayBase required')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        self._to_mds(index, value)


cdef class MDSIntArrayBase(MDSArrayBase):

    def _numeric_bounds_check(self, value):
        """
        This is per-type as it delegates to the associated primitive to do the
        bounds checking and follow Python/numpy conventions
        """
        raise NotImplementedError('Requires a type-specific instantiation')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        value = self._numeric_bounds_check(value)
        self._to_mds(index, value)

    property python_type:
        def __get__(self):
            return int


cdef class MDSFloatArrayBase(MDSArrayBase):

    property python_type:
        def __get__(self):
            return float

# TODO: Finish impl
cdef class RecordArray(MDSArrayBase):

    cdef h_marray_record_t _handle

    def __cinit__(self, int length=0):
        if length:
            self._handle = create_record_marray(<size_t> length)

    def __len__(self):
        return self._handle.size()

    def __hash__(self):
        return self._handle.hash1()

    property dtype:
        def __get__(self):
            return mds.typing.composites.record

    @classmethod
    def from_namespace(cls, Namespace namespace, path) -> Optional[RecordArray]:
        # cdef:
        #     String p = __cast_to_mds_string(path)
        #     h_istring_t ish = p._ish
        #     h_namespace_t nhandle = namespace._handle
        #     h_marray_record_t handle

        # try:
        #     handle = nhandle.lookup_record_array(ish, h_array_record_t())
        #     retval = RecordArray()
        #     retval._handle = handle
        #     return retval
        # except:
        #     return None
        return None # TODO FIX marray / array

    def bind_to_namespace(self, Namespace namespace):
        pass  # TODO: See how these properly bind


# TODO: Finish impl
cdef class StringArray(MDSArrayBase):

    cdef h_marray_string_t _handle

    def __cinit__(self, int length=0):
        if length:
            self._handle = create_string_marray(<size_t> length)

    def __len__(self):
        return self._handle.size()

    def __hash__(self):
        return self._handle.hash1()

    property dtype:
        def __get__(self):
            return mds.typing.composites.string

    @classmethod
    def from_namespace(cls, Namespace namespace, path) -> Optional[StringArray]:
        # cdef:
        #     String p = __cast_to_mds_string(path)
        #     h_istring_t ish = p._ish
        #     h_namespace_t nhandle = namespace._handle
        #     h_marray_string_t handle

        # try:
        #     handle = nhandle.lookup_string_array(ish, h_array_string_t())
        #     retval = StringArray()
        #     retval._handle = handle
        #     return retval
        # except:
        #     return None
        return None # TODO FIX marray / array

    def bind_to_namespace(self, Namespace namespace):
        pass  # TODO: See how these properly bind


# START INJECTION | tmpl_array_primitives(Primitives)
# END INJECTION

# =========================================================================
#  Records
# =========================================================================

class MDSRecordFieldMemberPair(object):
    """
    This is an internal class to deal with the fact that we don't have
    static variables per-se in Python, and certainly not in Cython, so
    we pair the instantiated RecordField with the type of the requested
    RecordMember (whether const or not), to be plugged into derived
    classes
    """

    def __init__(self, field: MDSRecordFieldBase, member: type):
        self.field = field  # derived <- MDSRecordFieldBase
        self.member = member  # type: derived <- MDSRecordMemberBase


# This is where we keep built record types, with the associated Lock
cdef __RECORD_DECLARATION_MUTEX = threading.Lock()
cdef __RECORD_DECLARED_TYPES = dict()
cdef __RECORD_IDENTS = dict()
cdef __RECORD_PROXIES = defaultdict(set)

cdef implant_record_handle(Record record, MDSRecordHandleWrapper wrapper):
    cdef h_record_type_t handle = wrapper._handle
    record._handle = handle.create_record()


cdef class MDSRecordProxy(object):
    cdef:
        Record _wrapped
        str _ident

    def __cinit__(self, type cls, str ident):
        self._wrapped = cls()
        self._ident = ident

    property is_complete:
        def __get__(self):
            return self._wrapped.ident == self._ident


cdef class Record(MDSObject):
    """
    The main Record, allowing complex data-structures using a combination of MDS
    and Python types.

    The MDS schema should be defined in a static method schema() returning a dictionary
    mapping field names (str) to field declarations. Examples are given.

    TODO: implement __getitem__ and __setitem__ to mask the write() read() ops, maybe make this primary?
    """
    cdef h_mrecord_t _handle

    def __cinit__(self):
        if self.__class__ is Record:
            raise TypeError('Cannot directly instantiate Record; a subclass is required.')

        implant_record_handle(self, self.type_decl.ensure_created())

    def __init__(self):
        self._register_fields()

    # def __richcmp__(a, b, op):
    #     if op == 2:  # ==
    #         return a._handle == b._handle
    #     elif op == 3:  # !=
    #         return a._handle != b._handle

    @classmethod
    def __init_subclass__(cls, ident: str, **kwargs):
        """
        This is called whenever a subclass of Record comes into scope, this
        provides a couple of nice opportunities:

        1) Ensure the type is properly declared in MDS before an instance
           is called, and bind the type declaration as a static member in
           Python-land
        2) TODO: See if any ambiguous proxies from Namespace are awaiting this
           specific implementation, and deal with that accordingly.
        """
        initialize_base_task()

        super().__init_subclass__(**kwargs)
        print(f"Called for {cls.__name__} with {ident}")

        # This is the same as rt_decl ... type_decl() in that it instantiates
        # the RecordTypeDeclarion (rt_decl)
        # This will store a reference in __RECORD_DECLARED_TYPES in a thread-safe way
        __RECORD_IDENTS[cls.__name__] = ident
        MDSRecordTypeDeclaration(cls, cls.schema()).ensure_created()
        
        # Now that this has come into scope, see if there are any previous proxies
        # to this type in the process-space; if so we should update their entires
        for proxy in __RECORD_PROXIES[ident]:
            pass # TODO Deal with this

    property type_decl:
        def __get__(self):
            return __RECORD_DECLARED_TYPES[self.ident]

    property ident:
        def __get__(self):
            return __RECORD_IDENTS[self.__class__.__name__]

    def _register_fields(self) -> None:
        """
        When this subclass was declared, we automatically registered the Record type
        with MDS; in so doing we stored single-instances of the RecordFields we required,
        but type references to the members, as they must be instance-bound.

        This method iterates through that container and updates the object's dict
        to enable dot notation access to the associated MemberRecords
        """
        # Stll need to make the RecordMembers and bind them to this instance
        for label, field_member_pair in self.type_decl.get_field_member_pairs().items():
            field, member_t = field_member_pair.field, field_member_pair.member
            self.__dict__[label] = member_t(record=self)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            h_istring_t nhandle = name._ish
            h_namespace_t h = namespace._handle

        # h.bind_record(nhandle, self._handle)

    @classmethod
    def from_namespace(cls, ns: Namespace, path: PathTypes) -> Record:
        if not isinstance(ns, Namespace):
            raise TypeError('Need a `Namespace` object as first argument')
    
        record = ns[path]
        retval = cls()
        # TODO: update retval's fields accordingly

        return retval

    @classmethod
    def force(cls) -> None:
        MDSManagedRecordType.ensure_complete(klass=cls)

    @staticmethod
    def schema() -> Dict[Text, MDSRecordFieldMemberPair]:
        raise TypeError("Derived `Record`s should return a `dict` detailing the schema here.")


def declare_field(type_decl: MDSTypeInfo) -> MDSRecordFieldMemberPair:
    """
    This returns the derived RecordField for the combination of the arguments.

    TODO: This only works for primitives, will need adaptation for {String, Array, Record}
    TODO: String-based hacking isn't neat, should make a dict using the generator,
    but this works for now.

    Args:
        type_decl:  MDSTypeInfo, obtained from `mds.typing`
    """
    if not isinstance(type_decl, MDSTypeInfo):
        raise TypeError("First parameter needs to be a type from `mds.typing`")

    # Now, let's see if it's known and of the correct lineage
    field_t = globals()[type_decl.title_record_field]
    assert issubclass(field_t, MDSRecordFieldBase)
    identifier = type_decl.title_record_member
    member_t = globals()[identifier]
    assert issubclass(member_t, MDSRecordMemberBase)

    # Unlike the CAPI we return both the instantiated field and a type for the member
    return MDSRecordFieldMemberPair(field=field_t(), member=member_t)


cdef class MDSManagedRecordType(MDSObject):
    cdef Record _parent

    def __cinit__(self, parent: Record):
        self._parent = parent

    def ensure_created(self) -> MDSRecordHandleWrapper:
        return self._parent.type_decl.ensure_created()

    @staticmethod
    def ensure_complete(klass: type) -> MDSRecordHandleWrapper:
        return klass.type_decl.ensure_created()

    def from_core(self, handle: MDSRecordHandleWrapper) -> Record:
  # mds_ptr<R> from_core(const Record::handle_t &val) const {
  #   if (val == nullptr) {
  #     return nullptr;
  #   }
  #   return from_handle(val);
  # }
        pass

    def to_core(self):
  # core_type to_core(const mds_ptr<R> &val) const {
  #   core_type tcv = val == nullptr ? core_type { } : val->_handle;
  #   return tcv;
  # }

  # core_type to_core(const mds_ptr<const R> &val) const {
  #   return val == nullptr ? core_type { } : val->_handle;
  # }
        pass

############################################################# RECORD FIELDS

cdef class MDSRecordFieldBase(MDSObject):
    """
    Base class to wrap around the field_handle_types, analog to CAPI::record_field

    There are no const RecordField, const-ness is handled by RecordMembers
    """

    def __getitem__(self, MDSRecordMemberBase member):
        # reference operator[](const mds_ptr<R> &r) const {
        #   R::type_decl().ensure_created();
        #   return reference(*this, *r);
        # }

        # reference operator[](R *r) const {
        #   R::type_decl().ensure_created();
        #   return reference(*this, *r);
        # }

        # const_reference operator[](const mds_ptr<const R> &r) const {
        #   R::type_decl().ensure_created();
        #   return const_reference(*this, *r);
        # }

        # const_reference operator[](const R *r) const {
        #   R::type_decl().ensure_created();
        #   return const_reference(*this, *r);
        # }
        member.record.type_decl.ensure_created()

        # So whether the reference is const or not, surely that'd be on the member's
        # constness, how to pass this through?
        # TODO: Double check this on the CAPI, seems to make sense on a per-meber
        #       granularity, though the CAPI looks like it's at Record
        return self.get_reference_type()(self, member.record)

    def ensure_type(self):
        """
        TODO: This should only be overridden and utilized for Record fields
        """
        pass

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        pass

    # These two, either use them in generated RecordFields and then Members, or
    # use overloaded calls in Members directly, then delete these.
    @staticmethod
    def from_core(val):
        pass

    @staticmethod
    def to_core(val):
        pass

    @staticmethod
    def get_reference_type() -> type:
        return None

# START INJECTION | tmpl_record_field_primitives(Primitives)
# END INJECTION

# START INJECTION | tmpl_record_field_arrays(Arrays)
# END INJECTION

######################################################################### REFERENCES

cdef class MDSRecordFieldReferenceBase(MDSObject):
    cdef:
        h_mrecord_t _record_handle

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        pass

  # static value_type from_core(const core_type &val) {
  #   return mtype().from_core(val);
  # }

  # /*
  #  * When we're and array field, the API read methods only get it as the base
  #  * array pointer, so we need to downcast.  This should be safe
  #  */
  # template<typename U = T, typename = std::enable_if_t<is_mds_array<U>::value>>
  # static value_type from_core(const api::managed_array_base_handle &handle) {
  #   using elt_type = typename mtype::elt_type;
  #   core_type h(handle.pointer()->template downcast<elt_type::kind>(),
  #                   handle.view());
  #   return from_core(h);
  # }

  # static core_type to_core(const value_type &val) {
  #   return mtype().to_core(val);
  # }

# START INJECTION | tmpl_record_field_reference_primitives(Primitives)
# END INJECTION

# START INJECTION | tmpl_record_field_reference_arrays(Arrays)
# END INJECTION

############################################################# RECORD MEMBERS

cdef class MDSRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing

    # using value_type = typename record_field<R,T>::value_type;

    def __cinit__(self, Record record, initial_value=None):
        self._enclosing = record

        if initial_value is not None:
            self.write(initial_value)

    def _field_ref(self) -> MDSRecordFieldReferenceBase:
        """
        Confusingly, in the MDS hierarchy, const_reference is the parent of
        reference, so the return type of this function may look to restrictive.
        It isn't.

        This is the actual RecordField, not Base... Need to think about this
        """
        pass

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        pass

    property record:
        def __get__(self):
            return self._enclosing


# START INJECTION | tmpl_record_member_primitives(Primitives)
# END INJECTION

# START INJECTION | tmpl_record_member_arrays(Arrays)
# END INJECTION

######################################################### RECORD TYPE DECLARATIONS

class MDSRecordFieldDeclaration(object):
    """
    This could probably be avoided, but it's copying CAPI
    """

    def __init__(self, name: String, field: MDSRecordFieldBase):
        self.name = name
        self.field = field


cdef class MDSRecordHandleWrapper(object):
    cdef:
        h_record_type_t _handle
        # h_c_record_type_t _handle

cdef emplace_handle(h_record_type_t wrapped):
    wrapper = MDSRecordHandleWrapper()
    wrapper._handle = wrapped
    return wrapper

cdef emplace_const_handle_from_decl(MDSRecordTypeDeclaration decl):
    wrapper = MDSRecordHandleWrapper()
    wrapper._handle = decl._created_type
    return wrapper


cdef MDSRecordHandleWrapper __declare_mds_record(h_istring_t ish, MDSRecordHandleWrapper wrapper):
    cdef:
        MDSRecordHandleWrapper retval = MDSRecordHandleWrapper()
        h_c_record_type_t unwrapped_handle = wrapper._handle
        h_record_type_t new_handle = h_record_type_t.declare(ish, unwrapped_handle)

    retval._handle = new_handle
    return retval


cdef class MDSRecordTypeDeclaration(object):
    cdef:
        list                _field_decls
        dict                _field_member_pairs
        h_record_type_t     _declared_type
        h_c_record_type_t   _created_type
        type                _cls

    def __cinit__(self, cls: type, field_member_pairs: Dict[Text, MDSRecordFieldMemberPair]):
        cdef MDSRecordHandleWrapper wrapper = self.declare(
            String(__RECORD_IDENTS[cls.__name__]),
            cls.__bases__[0]
        )

        self._declared_type = h_record_type_t(wrapper._handle)
        self._cls = cls
        self._field_decls = list()
        self._field_member_pairs = field_member_pairs
        self.note_fields(field_member_pairs)

    def get_field_member_pairs(self) -> dict:
        return self._field_member_pairs

    @staticmethod
    def declare(name: String, parent: type) -> MDSRecordHandleWrapper:
        """
        The logic of this, from the CAPI, is that we want to declare a type
        of name `name`, and we check its ancestor;

        1) If the ancestor is Record, just declare it.
        2) If the direct ancestor is not Record, make sure that
           itself is an instance thereof

        TODO: s should be a parameterized managed_type<R>?
        """
        print(f"?> Declaring {name} with parent {parent.__name__}")
        cdef h_istring_t ish = __extract_ish(name)

        if parent is Record:
            return emplace_handle(h_record_type_t.declare(ish, h_c_record_type_t()))

        assert issubclass(parent, Record), "Super type not a record type"
        print(f" > Passed subclass assertion")
        # As soon as `s` came into scope, it should have registered its type,
        # so this is unnecessary, but left in for posterity.
        sp = parent.type_decl.ensure_created()  # MDSRecordHandleWrapper
        print(f" > Ensure created run OK on parent, returned {sp}")
        return __declare_mds_record(ish, sp)

    def note_fields(self, fields: Dict[Text, MDSRecordFieldMemberPair]) -> None:
        for label, field_member_pair in fields.items():
            self._field_decls.append(
                MDSRecordFieldDeclaration(
                    String(label),  # We want to grab the h_istring_t later
                    field_member_pair.field
                )
            )

    def declare_fields(self) -> None:
        for fd in self._field_decls:
            fd.field.declare(fd.name, self)

    def ensure_field_types(self) -> None:
        for fd in self._field_decls:
            fd.field.ensure_type()

    def ensure_created(self) -> MDSRecordHandleWrapper:
        ident = __RECORD_IDENTS[self._cls.__name__]

        if not ident in __RECORD_DECLARED_TYPES:
            with __RECORD_DECLARATION_MUTEX:
                # Ensure no one else has beat us to the punch (call_once)
                if not ident in __RECORD_DECLARED_TYPES:
                    self.declare_fields()
                    self._created_type = h_c_record_type_t(self._declared_type.ensure_created())
                    self.ensure_field_types()
                    __RECORD_DECLARED_TYPES[ident] = self

        return emplace_const_handle_from_decl(__RECORD_DECLARED_TYPES[ident])

# =========================================================================
#  Strings
# =========================================================================

cdef class String(MDSIndexedObject):
    """
    This class provides the functionality expected from the native str type,
    but backed by MDS. As with str, Strings are immutable.
    """
    cdef:
        h_mstring_t _handle
        h_istring_t _ish

    def __cinit__(self, value=""):
        self._ish = convert_py_to_ish(value) 
        self._handle = h_mstring_t(self._ish)
        self.__iter_idx = 0

    def __len__(self):
        return self._handle.length()

    def __hash__(self):
        return self._handle.hash1()

    def __str__(self):
        return <str> self._handle.utf8().decode("utf-8")

    def __repr__(self):
        return "'{}'".format(str(self))

    def __getitem__(self, item):
        cdef:
            string s
            int i
            char_t c

        if isinstance(item, int):
            c = self._handle.at(item)
            u = chr(c)
            return u
        elif isinstance(item, slice):
            # TODO: Check this
            s.reserve((item.stop - item.start) // item.step)

            for i in range(start=item.start, stop=item.stop, step=item.step):
                s.push_back(self._handle.at(i))

            return String(s)

        raise TypeError(
            "list indices must be integers or slices, not {}".format(
                type(item)
            )
        )

    def __add__(self, other):
        """
        Concatenates this string with another, returns this as a new String
        """
        # TODO: Could probably open this to [str, bytes] too.
        cdef:
            string s
            str c

        if isinstance(other, String):       
            s.reserve(<size_t> (len(self) + len(other)))

            # Chain the iterators to avoid any string copying
            for c in chain(iter(self), iter(other)):
                s.push_back(ord(c))  # Need as an int for char

            return String(s)

        raise TypeError("must be String")

    def __mul__(self, other):
        """
        Internal method to perform String multiplication without overhead
        """
        cdef:
            string s
            str c
            int it, l = len(self)

        if isinstance(other, int):
            s.reserve(l * other)

            for it in range(other):
                for c in self:
                    s.push_back(ord(c))

            return String(<unicode> s.decode("utf-8"))

        raise TypeError(
            "can't multiply sequence by non-int of type 'String'"
        )

    def __rmul__(self, other):
        pass

    def __mod__(self, other):
        pass

    def __rmod__(self, other):
        pass

    # def __richcmp__(a, b, op):
    #     if op == 0:    # <
    #         return a._handle < b._handle
    #     elif op == 1:  # <=
    #         return a._handle <= b._handle
    #     elif op == 2:  # ==
    #         return a._handle == b._handle
    #     elif op == 3:  # !=
    #         return a._handle != b._handle
    #     elif op == 4:  # >
    #         return a._handle > b._handle
    #     elif op == 5:  # >=
    #         return a._handle >= b._handle

    def __sizeof__(self):
        return self._handle.size()

    # TODO: Write equivalents that use the MDS-stored data

    def capitalize(self):
        return String(str(self).capitalize())

    def casefold(self):
        return String(str(self).casefold())

    def center(self, *args, **kwargs):
        return String(str(self).center(*args, **kwargs))

    # TODO: encode(encoding="utf-8", errors="strict")

    def endswith(self, *args, **kwargs):
        return str(self).endswith(*args, **kwargs)

    def expandtabs(self, *args, **kwargs):
        return String(str(self).expandtabs(*args, **kwargs))

    def find(self, *args, **kwargs):
        return str(self).find(*args, **kwargs)

    def format(self, *args, **kwargs):
        return String(str(self).format(*args, **kwargs))

    def format_map(self, *args, **kwargs):
        return String(str(self).format_map(*args, **kwargs))

    def index(self, *args, **kwargs):
        return str(self).index(*args, **kwargs)

    def isalnum(self, *args, **kwargs):
        return str(self).isalnum(*args, **kwargs)

    def isalpha(self, *args, **kwargs):
        return str(self).isalpha(*args, **kwargs)

    def isdecimal(self, *args, **kwargs):
        return str(self).isdecimal(*args, **kwargs)

    def isdigit(self, *args, **kwargs):
        return str(self).isdigit(*args, **kwargs)
    
    def isidentifier(self, *args, **kwargs):
        return str(self).isidentifier(*args, **kwargs)
    
    def islower(self, *args, **kwargs):
        return str(self).islower(*args, **kwargs)

    def isnumeric(self, *args, **kwargs):
        return str(self).isnumeric(*args, **kwargs)

    def isprintable(self, *args, **kwargs):
        return str(self).isprintable(*args, **kwargs)

    def isspace(self, *args, **kwargs):
        return str(self).isspace(*args, **kwargs)

    def istitle(self, *args, **kwargs):
        return str(self).istitle(*args, **kwargs)

    def isupper(self, *args, **kwargs):
        return str(self).isupper(*args, **kwargs)

    def join(self, *args, **kwargs):
        return String(str(self).join(*args, **kwargs))

    def ljust(self, *args, **kwargs):
        return String(str(self).ljust(*args, **kwargs))

    def lower(self, *args, **kwargs):
        return String(str(self).lower(*args, **kwargs))

    def lstrip(self, *args, **kwargs):
        return String(str(self).lstrip(*args, **kwargs))

    def partition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).partition(*args, **kwargs)])

    def replace(self, *args, **kwargs):
        return String(str(self).replace(*args, **kwargs))

    def rfind(self, *args, **kwargs):
        return str(self).rfind(*args, **kwargs)

    def rindex(self, *args, **kwargs):
        return str(self).rindex(*args, **kwargs)

    def rjust(self, *args, **kwargs):
        return String(str(self).rjust(*args, **kwargs))

    def rpartition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).rpartition(*args, **kwargs)])

    def rsplit(self, *args, **kwargs):
        return [String(x) for x in str(self).rsplit(*args, **kwargs)]

    def rstrip(self, *args, **kwargs):
        return String(str(self).rstrip(*args, **kwargs))

    def split(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def splitlines(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def startswith(self, *args, **kwargs):
        return str(self).startswith(*args, **kwargs)

    def strip(self, *args, **kwargs):
        return String(str(self).strip(*args, **kwargs))
    
    def swapcase(self, *args, **kwargs):
        return String(str(self).swapcase(*args, **kwargs))

    def title(self, *args, **kwargs):
        return String(str(self).title(*args, **kwargs))

    # TODO: translate

    def upper(self, *args, **kwargs):
        return String(str(self).upper(*args, **kwargs))

    def zfill(self, *args, **kwargs):
        return String(str(self).zfill(*args, **kwargs))


cdef inline h_istring_t __extract_ish(String s):
    cdef h_istring_t retval = s._ish
    return retval

cdef String __cast_to_mds_string(object possible_str):
    if isinstance(possible_str, String):
        return possible_str
    if isinstance(possible_str, str):
        return String(possible_str)

    raise TypeError("`{}` is not a valid `str` type.".format(type(possible_str)))

# =========================================================================
#  Namespace
# =========================================================================

PathTypes = Union[str, String, Path]

cdef __NAMESPACE_ROOT = None
cdef __NAMESPACE_SEPARATOR = "/"

ctypedef fused strings:
    str
    String


cdef bint __namespaces_equal(Namespace a, Namespace b):
    return a._handle == b._handle


class IllegalPathException(Exception):
    
    def __init__(self, path: Path, *args, **kwargs):
        self._path = path
        super().__init__(*args, **kwargs)


cdef class Path(object):
    cdef:
        Impl _ptr

    def __cinit__(self, impl=None):
        if isinstance(impl, Impl):
            self._ptr = impl
        else:
            self._ptr = Impl()

    def resolve(self, cpts: List[Path]) -> Path:
        return Path(impl=self._ptr.resolve(cpts))

    def __str__(self):
        return str(self._ptr)

    @staticmethod
    def of(cpts: List[Path]) -> Path:
        return Path(impl=Impl(cpts))

    property is_absolute:
        def __get__(self):
            return self._ptr.is_absolute


cdef class Impl(object):
    cdef:
        bool    _absolutep
        size_t  _initial_ups
        list    _names

    def __cinit__(self, cpts: List[Path]):
        self._absolutep = False
        self._initial_ups = 0
        self._names = list()

        if isinstance(cpts, list):
            self.extend(cpts)
        else:
            self.append_cpt(cpts)

    def __str__(self):
        delim = __NAMESPACE_SEPARATOR
        compiled = delim if self.absolutep else ""
        compiled += "..{delim}" * self.initial_ups
        compiled += "{delim}".join(self.names)
        return compiled

    def up_levels(self, size_t levels) -> None:
        current = len(self._names)

        if not self.is_absolute and (levels > current):
            self._initial_ups += levels - current

    def reset_to_root(self) -> None:
        self._names = list()
        self._initial_ups = 0
        self._absolutep = True

    @staticmethod
    def self_cpt() -> String:
        return String(".")

    @staticmethod
    def up_cpt() -> String:
        return String("..")

    def append(self, cpt: String) -> None:
        if cpt == self.self_cpt():
            return
        elif cpt == self.up_cpt():
            self.up_levels(1)
        else:
            self._names.append(cpt)

    def extend(self, cpts: List[Path], absolute=False) -> None:
        if absolute:
            self.reset_to_root()

        for cpt in cpts:
            self.append_cpt(cpt)

    def copy(self) -> Impl:
        return __copy_Impl(self)

    def resolve(self, cpts: List[Path]) -> Impl:
        impl = self.copy()
        impl.extend(cpts)

        return impl

    def append_cpt(self, cpt: Union[Path, String]) -> None:
        cdef:
            Impl impl
            size_t ups

        if isinstance(cpt, Path):
            impl = cpt._ptr

            if impl.is_absolute:
                self.reset_to_root()
            else:
                ups = impl.initial_ups

                if ups:
                    self.up_levels(ups)

            self._names.extend(impl._names.copy())
        else:  # TODO: Change this when String supports .split() and __contains__
            delim = __NAMESPACE_SEPARATOR
            s = str(cpt)

            if delim in s:
                self.append(cpt)
                return

            if s.startswith(delim):
                self.reset_to_root()

            parts = [String(x) for x in s.split(delim)]

            for name in parts:
                self.append(name)

    property is_absolute:
        def __get__(self):
            return <bint> self._absolutep

    property absolutep:
        def __get__(self):
            return self._absolutep

    property names:
        def __get__(self) -> List[String]:
            return self._names

    property initial_ups:
        def __get__(self) -> int:
            return self._initial_ups


cdef class Namespace(MDSObject):
    cdef:
        h_namespace_t   _handle
        Namespace       _parent
        String          _name

    def __cinit__(self, Namespace parent, name):
        cdef:
            String definite = __cast_to_mds_string(name)

        self._parent = parent
        self._name = definite

    def __setitem__(self, path: PathTypes, value: MDSObject):
        binding = self[path]
        binding.bind(value)

    def __getitem__(self, path: PathTypes) -> MDSNameBinding:
        """
        So this is basically an amalgamation of at() and _at() in the CAPI
        """
        if isinstance(path, str) or isinstance(path, String):
            path = Path.of(path)

        if path.is_absolute:
            raise IllegalPathException(path)

        return self.resolve_to_binding(path)

    def resolve(self, p: Path, include_last=True) -> Namespace:
        cdef:
            Impl pi = p._ptr
            Namespace iptr = self

        if p.is_absolute:
            iptr = Namespace.root()

        for i in range(pi.initial_ups):
            if iptr.is_root():
                raise IllegalPathException(p)

            iptr = iptr.parent()

        names = pi.names

        if not names:
            if include_last:
                return iptr
            if iptr.is_root():
                raise IllegalPathException(p)

            return iptr

        n = len(names)

        if not include_last:
            n -= 1

        for i in range(n):
            nb = MDSNameBinding(iptr, names[i])
            iptr = nb.as_namespace()

        return iptr

    def resolve_to_binding(self, p: Path) -> MDSNameBinding:
        cdef:
            Namespace ip = self.resolve(p=p, include_last=False)
            Impl pi = p._ptr
            list names = pi.names
            String name = String() if len(names) == 0 else names[-1]

        return MDSNameBinding(ip, name)

    @staticmethod
    def make(parent: Namespace, name: PathTypes):
        initialize_base_task()  # Orig: ensure_thread_initialized()
        return Namespace(parent=parent, name=name)

    @staticmethod
    def root():
        global __NAMESPACE_ROOT

        if __NAMESPACE_ROOT is None:
            __NAMESPACE_ROOT = Namespace_Init(h_namespace_t._global(), None, String())

        return __NAMESPACE_ROOT

    @staticmethod
    def current() -> Namespace:
        return MDSThreadData.current_namespace

    @staticmethod
    def from_path(path: PathTypes) -> Namespace:
        p = Path.of(path)
        base = Namespace.root() if p.is_absolute else Namespace.current()
        return base.resolve(p)

    @staticmethod
    def from_absolute_path(path: PathTypes) -> Namespace:
        p = Path.of(path)
        return Namespace.root().resolve(p)

    # def create_child(self, child_id: PathTypes, create_if_missing=True) -> Optional[Namespace]:
    #     cdef:
    #         h_istring_t ish
    #         h_namespace_t handle
    #         String definite

    #     definite = __cast_to_mds_string(child_id)
    #     ish = definite._ish
    #     handle = self._handle.child_namespace(ish, <bint> create_if_missing)

    #     if handle.is_null():
    #         return None

    #     return Namespace_Init(handle=handle)


    # @staticmethod
    # def get_global() -> Namespace:
    #     return Namespace_Init(handle=h_namespace_t._global())

    # @staticmethod
    # def get_current():
    #     # TODO: When is this set? Check the CAPI / JAPI
    #     return Namespace_Init(handle=current_namespace())

    def parent(self) -> Namespace:
        # TODO: Const namespace?
        if self.is_root():
            return Namespace.root()

        return self._parent

    def name(self) -> String:
        return self._name

    def is_root(self):
        return __namespaces_equal(self, Namespace.root()) # TODO Cython 0.27

    property SEPARATOR:
        def __get__(self):
            return __NAMESPACE_SEPARATOR


cdef inline Namespace_Init(h_namespace_t handle, Namespace parent, String name):
    initialize_base_task()
    result = Namespace(parent=parent, name=name)
    result._handle = handle
    return result

cdef Impl __copy_Impl(Impl origin):
    cdef impl = Impl()
    impl._names = origin.names.copy()
    impl._initial_ups = origin.initial_ups
    impl._absolutep = origin.absolutep
    return impl


cdef class MDSNameBindingBase(object):
    cdef:
        Namespace   _namespace
        String      _name

    def __cinit__(self, Namespace ns, String n):
        self._namespace = ns
        self._name = n

    def is_bound(self):
        return self._namespace._handle.is_bound(self._name._ish)

    def bind(self, *args, **kwargs):
        pass


cdef class MDSNameBinding(MDSNameBindingBase):
    cdef:
        bint _root_binding

    def __cinit__(self, Namespace ns, String n):
        super().__init__(ns, n)
        self._root_binding = False

        if not len(n):
            if ns.is_root():
                self._root_binding = True
                self._namespace = None
            else:
                self._name = ns.name()
                self._namespace = ns.parent()

    def as_type(self, t: MDSTypeInfo) -> MDSTypedNameBinding:
        mappings = {
            # START INJECTION | tmpl_namespace_mapping(Primitives,Arrays,Composites)
            # END INJECTION
        }

        if t not in mappings:
            raise TypeError(f"No way to cast to type `{t}`")

        return mappings[t](self._namespace, self._name)

    def as_array(self, array_type: MDSArrayTypeInfo) -> MDSArrayBase:
        # TODO deal with title_array => title in MDSArrayTypeInfo
        klass = globals()[array_type.title_array]
        return self.as_type(klass)

    def as_namespace(self) -> Namespace:
        cdef:
            h_istring_t nhandle = self._name._ish
            h_namespace_t h = self._namespace._handle
            h_namespace_t ch

        if self._root_binding:
            return Namespace.root()

        ch = h.child_namespace(nhandle, True)
        return Namespace_Init(handle=ch, parent=self._namespace, name=self._name)

    def bind(self, value: MDSPrimitiveBase):
        # TODO: What should be bind-able?
        # cdef:
        #     h_istring_t nhandle = self._name._ish
        #     h_namespace_t h = self._namespace._handle
        if not isinstance(value, MDSPrimitiveBase):
            raise TypeError("Can't bind a non `MDSObject`")
        # I can either do an if/elif for every possible wrapper, or just
        # delegate to it. I'll do the latter.
        # h.bind<managed_type<T>::kind>(nhandle, std::forward<T>(val));
        # h.bind(nhandle, value)
        value.bind_to_namespace(namespace=self._namespace, name=self._name)
        

cdef class MDSTypedNameBinding(MDSNameBindingBase):

    def __cinit__(self, Namespace ns, String n):
        super().__init__(ns, n)

    def get(self) -> Optional[MDSObject]:
        pass

    def bind(self, val):
        pass

    def check(self):
        return self.get() is not None


cdef class MDSStringNameBinding(MDSTypedNameBinding):
    pass


cdef class MDSRecordNameBinding(MDSTypedNameBinding):
    pass


# START INJECTION | tmpl_namespace_typed_primitive_bindings(Primitives)
# END INJECTION

# START INJECTION | tmpl_namespace_typed_array_bindings(Arrays)
# END INJECTION

# =========================================================================
#  Primitives
# =========================================================================

# START INJECTION | tmpl_primitives(Primitives)
                                                                                                                                                                                                                                # END INJECTION
